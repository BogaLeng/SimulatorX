# 网络同步
::: tip 在网络同步方案上，与2022版本相同，我们仍然使用Mirror网络库。
:::

## Flux与Mirror融合的架构
Flux的Action在服务器端流动，实现功能后同步至客户端进行效果展示。

### 基本原理

![image](/static/images/arch-flux-01.png)

### Flux
由于不好区分 Store 和 View，我们将这两个合到了一起，由 Dispatcher，Store，Action 三种成分构成。

#### Pros：
- 组件结构规范、耦合度低。
- Dispatcher 的存在方便实现录制、统计等功能。
- 应对规则修改，迭代快速

#### Cons：
- 需要同步修改 Action，InputActions，Receive 存在心智负担。
- 受 Flux 结构限制，事件传播只有单链，某些逻辑实现很绕。
- 运行在主线程上的 Dispatcher 和分帧发送可能形成性能瓶颈。
- 事件没有复用，无限 new 导致内存占用增长。
- 没有事件监控，传播路径和影响范围难以查明，Debug 困难。
- 跨端同步实现不够自然。
- 使用字符串做事件索引，存在心智负担、性能损耗。

### Mirror
结合 Flux，两端之间通信的时机和内容都管理得比较好。

#### Pros:
- 组件丰富，又加上了 Smooth Sync，总的来说使用很舒适。
- 两端之间通信链路限死，再怎么 Bug 都是那一条，排查方便。
- 同时可以做服务端客户端，而且局域网公网可切换。
- 公网运行稳定，没有出过太多幺蛾子。

#### Cons:
- 从零基础到学习上手，有很多概念要掌握，包括共用一套代码。
- 今年全部移到服务端，搞得客户端都没有预测，同步会卡。
- 跨端同步强行弄了个 ChildAction 出来，能用但是很诡异。
- Mirror 自带的房间管理不算特别好用。
- 子弹等依然是各仿真各的，结果一致。

### 今年改进
我们对网络同步逻辑进行了进一步优化，解决了部分前几个版本没能解决的遗留问题。
Flux与Mirror融合的架构
Flux的Action在服务器端流动，实现功能后同步至客户端进行效果展示。
但是，在这种情况下，Action异常过多时会导致服务器端信息阻塞，从而影响所有游戏玩家的游戏体验。在2023版本中进行了一定的修正。

:::warning 但是
在这种情况下，Action异常过多时会导致服务器端信息阻塞，从而影响所有游戏玩家的游戏体验。在2023版本中进行了一定的修正。
:::